# 마이크로서비스 글로벌 로깅 전략 계획

## 요구사항

1. **일관성**: 세 마이크로서비스(게이트웨이, 인증, 이벤트)에서 일관된 로깅 형식 사용
2. **중앙화**: 모든 로그를 중앙 저장소에 수집하여 통합 분석 가능
3. **구조화**: JSON 형식으로 구조화된 로그 데이터 생성
4. **컨텍스트 추적**: 요청 ID를 통한 서비스 간 트랜잭션 추적 기능
5. **로그 레벨**: 적절한 로그 레벨 구분(DEBUG, INFO, WARN, ERROR)
6. **성능**: 로깅으로 인한 서비스 성능 저하 최소화
7. **보안**: 민감 정보 필터링 및 로그 접근 제어
8. **확장성**: 새로운 마이크로서비스 추가 시 쉽게 통합 가능한 구조

## 현재 구현 상태

### 기술 스택

1. **로깅 라이브러리**: NestJS + Pino 기반 커스텀 로거 (@libs/logger)
2. **로그 수집 및 저장**: Grafana Alloy + Loki
3. **분산 추적**: 요청 ID 기반 추적 구현
4. **시각화**: Grafana

### 주요 구현 기능

1. **공통 로깅 모듈**:
   - Pino 기반 JSON 형식 로깅
   - 서비스별 로거 설정 (`serviceName` 필드로 구분)
   - 환경변수(`LOG_LEVEL`) 또는 설정을 통한 로그 레벨 관리
   - 개발 환경용 prettyPrint 지원

2. **컨텍스트 관리**:
   - AsyncLocalStorage를 활용한 요청 컨텍스트 관리
   - 요청 ID 자동 생성 및 전파 (HTTP 헤더 `X-Request-Id` 활용)
   - 사용자 ID, 경로, 메서드 등 컨텍스트 정보 자동 수집

3. **민감 정보 필터링**:
   - 설정 가능한 마스킹 규칙 (`sensitiveDataOptions`)
   - 기본 민감 필드 마스킹 (비밀번호, 토큰, 인증 헤더 등)
   - 객체 경로 기반 필터링 지원

4. **로그 수집 및 통합**:
   - Grafana Alloy 에이전트를 통한 Docker 컨테이너 로그 수집
   - JSON 로그에서 구조화된 필드 추출 (requestId, serviceId, level 등)
   - Loki에 중앙 저장

5. **서비스별 구현**:
   - 게이트웨이 서비스: `gateway` 서비스 ID 사용, INFO 기본 레벨
   - 인증 서비스: `auth-service` 서비스 ID 사용, INFO 기본 레벨
   - 이벤트 서비스: `event-service` 서비스 ID 사용, INFO 기본 레벨

### 로그 형식

현재 모든 서비스는 다음과 같은 통일된 JSON 형식을 사용합니다:

```json
{
  "timestamp": "2023-07-20T10:15:30.123Z",
  "level": "info",
  "msg": "로그 메시지",
  "serviceId": "서비스명",
  "requestId": "고유-요청-ID",
  "userId": "사용자-ID",
  "path": "/api/endpoint",
  "method": "GET",
  "clientIp": "127.0.0.1",
  "userAgent": "사용자-에이전트-정보",
  "component": "컴포넌트명",
  "additionalContext": "추가 컨텍스트 데이터"
}
```

## 기술 스택 제안

1. **로깅 라이브러리**: NestJS Logger + Pino (현재 구현됨)
2. **로그 수집 및 저장**: Grafana Alloy + Loki (현재 구현됨)
3. **분산 추적**: OpenTelemetry 통합 (향후 개선)

## 작업 계획

### 1. 공통 로깅 모듈 구현

#### 1.1 공통 로깅 인터페이스 설계

- **작업**: 모든 마이크로서비스에서 사용할 로깅 인터페이스 정의 ✅
- **하위 작업**:
  - Pino 및 NestJS Logger 통합 클래스 구현 ✅
    - 로거 팩토리 생성: 서비스명을 매개변수로 받아 일관된 설정의 Pino 로거 인스턴스 생성 ✅
    - NestJS LoggerService 인터페이스 구현: NestJS 프레임워크와 통합을 위한 래퍼 클래스 구현 ✅
    - 필요한 로깅 메서드 구현: log, error, warn, debug, verbose 등의 메서드 정의 ✅
  - 로그 형식 정의(시간, 서비스명, 요청 ID, 레벨, 메시지, 메타데이터) ✅
    - Pino 기본 포맷 확장: timestamp, level, message에 추가 필드 정의 ✅
    - 표준 컨텍스트 필드 정의: serviceId, traceId, spanId, userId 등 ✅
    - 로그 포맷 JSON 스키마 작성: 모든 서비스가 일관된 포맷을 사용하도록 보장 ✅
  - 로그 레벨 관리 유틸리티 구현 ✅
    - 환경 변수에 따른 로그 레벨 설정 기능: LOG_LEVEL 환경 변수 활용 ✅
    - 실행 시간 로그 레벨 변경 인터페이스: 필요시 로그 레벨을 동적으로 변경할 수 있는 메서드 ✅
    - 로그 필터링 헬퍼: 특정 모듈/컴포넌트에 대한 로그 레벨을 세부적으로 조정하는 유틸리티 ✅
- **검증 방법**:
  - 각 로거 메서드가 올바른 로그 레벨과 형식으로 출력하는지 단위 테스트
  - 다양한 상황(정상 처리, 예외, 비동기 작업 등)에서 로깅이 올바르게 작동하는지 검증
  - 모든 필수 필드가 로그에 포함되는지 확인

#### 1.2 로그 컨텍스트 관리자 구현

- **작업**: 요청 컨텍스트(요청 ID, 사용자 정보 등) 관리 클래스 구현 ✅
- **하위 작업**:
  - 요청 ID 생성/전파 유틸리티 구현 ✅
    - UUID v4 기반 고유 ID 생성기: 모든 요청에 대한 고유 식별자 생성 ✅
    - HTTP 헤더 추출/주입 기능: 'X-Request-Id' 헤더 처리 로직 ✅
    - 마이크로서비스 간 ID 전파 메커니즘: 구현 필요
  - AsyncLocalStorage를 활용한 컨텍스트 저장소 구현 ✅
    - 요청별 컨텍스트 관리: 각 요청 라이프사이클 동안 컨텍스트 데이터 유지 ✅
    - 비동기 호출 간 컨텍스트 전파: 프로미스 체인과 콜백에서 컨텍스트 유지 ✅
    - NestJS ExecutionContext와 통합: 요청 핸들러에서 컨텍스트 자동 설정 ✅
  - 요청 메타데이터 추출 헬퍼 구현 ✅
    - HTTP 요청 메타데이터 추출: 클라이언트 IP, 사용자 에이전트, URL 경로 등 수집 ✅
    - RPC/이벤트 메타데이터 추출: 마이크로서비스 통신에서 관련 정보 수집 (부분 구현)
    - 사용자 인증 정보 추출: 인증 토큰에서 사용자 ID 및 권한 정보 수집 ✅
- **검증 방법**:
  - 동일 요청 ID가 서비스 간 전파되는지 통합 테스트
  - 비동기 코드에서도 컨텍스트가 유지되는지 확인
  - 다양한 요청 패턴(HTTP, gRPC, 이벤트 등)에서 올바른 메타데이터가 수집되는지 검증

#### 1.3 민감 정보 필터링 구현

- **작업**: 로그 출력 전 민감 정보 마스킹 기능 구현 ✅
- **하위 작업**:
  - 마스킹 규칙 정의(이메일, 비밀번호, 토큰 등) ✅
    - 기본 필터링 패턴 정의: 구현 필요
    - 키워드 기반 필터링: password, token, secret 등의 키가 포함된 필드 마스킹 ✅
    - 객체 경로 기반 필터링: 특정 객체 경로의 값(req.body.password 등) 마스킹 ✅
  - 민감 정보 감지 및 대체 로직 구현 ✅
    - JSON 객체 재귀 처리: 중첩된 객체 내 민감 정보 처리 ✅
    - 문자열 검사 및 마스킹: 로그 메시지 내 민감 정보 마스킹 ✅
    - 마스킹 자리 표시자 구현: 민감 정보를 '***MASKED***'로 대체 ✅
  - 설정을 통한 필터링 규칙 조정 기능 ✅
    - 설정 파일 기반 규칙 관리: 서비스별 모듈 설정으로 마스킹 규칙 정의 ✅
    - 서비스별 설정 분리: 마이크로서비스별 고유한 마스킹 요구사항 지원 ✅
    - 런타임 규칙 업데이트: 서비스 재시작 없이 마스킹 규칙 갱신 기능 (구현 필요)
- **검증 방법**:
  - 다양한 민감 데이터 패턴을 포함한 테스트 로그 생성
  - 로그 출력 결과에서 민감 정보가 마스킹되었는지 확인
  - 마스킹이 성능에 미치는 영향 측정

### 2. 마이크로서비스별 로깅 구현

#### 2.1 게이트웨이 서비스 로깅 구현

- **작업**: 게이트웨이 서비스에 글로벌 로깅 설정 ✅
- **하위 작업**:
  - 공통 로깅 모듈 통합 ✅
    - 패키지 의존성 추가: @nestjs/pino 및 공통 로깅 모듈 추가 ✅
    - 로깅 모듈 설정: 애플리케이션 부트스트랩 과정에서 로거 설정 ✅
    - 서비스명 및 기본 컨텍스트 설정: 'gateway' 식별자 설정 ✅
  - 인터셉터를 통한 요청/응답 로깅 구현 (부분 구현)
    - HTTP 요청 시작/종료 로깅: 요청 시간, 경로, 메서드, 상태 코드, 응답 시간 기록 (부분 구현)
    - 요청 본문 및 쿼리 파라미터 로깅: 크기 제한 및 민감 정보 필터링 적용 (부분 구현)
    - 성능 메트릭 수집: 응답 시간, 처리 지연 등 성능 관련 데이터 수집 (미구현)
  - 에러 필터를 통한 예외 로깅 구현 ✅
    - 글로벌 예외 필터 구현: 모든 예외를 일관된 형식으로 로깅 ✅
    - 예외 스택 트레이스 포맷팅: 개발/운영 환경에 따른 스택 트레이스 처리 ✅
    - 에러 분류 및 심각도 설정: 에러 유형에 따른 로그 레벨 조정 (부분 구현)
- **검증 방법**:
  - 다양한 API 엔드포인트에 대한 테스트 요청 실행
  - 요청/응답 데이터가 기대한대로 로깅되는지 확인
  - 에러 발생 시 적절한 로그 레벨과 컨텍스트로 기록되는지 검증

#### 2.2 인증 서비스 로깅 구현

- **작업**: 인증 서비스에 글로벌 로깅 설정 ✅
- **하위 작업**:
  - 공통 로깅 모듈 통합 ✅
    - 패키지 의존성 추가: @nestjs/pino 및 공통 로깅 모듈 추가 ✅
    - 로깅 모듈 설정: 애플리케이션 부트스트랩 과정에서 로거 설정 ✅
    - 서비스명 및 기본 컨텍스트 설정: 'auth-service' 식별자 설정 ✅
  - 인증 이벤트(로그인, 토큰 발급 등) 로깅 구현 (부분 구현)
    - 사용자 인증 시도 로깅: 성공/실패 여부, IP 주소, 사용자 ID(성공 시) (부분 구현)
    - 토큰 발급/갱신 로깅: 토큰 유형, 만료 시간, 사용자 ID(토큰 ID는 마스킹) (부분 구현)
    - 권한 변경 로깅: 사용자 권한 부여/철회 이벤트 기록 (미구현)
  - 민감 정보 필터링 설정 ✅
    - 인증 서비스 특화 마스킹 규칙: 비밀번호, 토큰, 보안 질문 등 마스킹 ✅
    - 사용자 식별 정보 부분 마스킹: 이메일, 전화번호 등 부분적 표시 ✅
    - 관리자 액션 로깅 강화: 관리자 수행 작업에 대한 상세 로깅(권한 변경 등) (미구현)
- **검증 방법**:
  - 로그인, 토큰 발급, 권한 변경 등 인증 관련 테스트 시나리오 실행
  - 로그에서 민감 정보가 노출되지 않는지 확인
  - 인증 실패 시도가 적절히 로깅되는지 검증

#### 2.3 이벤트 서비스 로깅 구현

- **작업**: 이벤트 서비스에 글로벌 로깅 설정 ✅
- **하위 작업**:
  - 공통 로깅 모듈 통합 ✅
    - 패키지 의존성 추가: @nestjs/pino 및 공통 로깅 모듈 추가 ✅
    - 로깅 모듈 설정: 애플리케이션 부트스트랩 과정에서 로거 설정 ✅
    - 서비스명 및 기본 컨텍스트 설정: 'event-service' 식별자 설정 ✅
  - 이벤트 생성/처리 로깅 구현 (부분 구현)
    - 이벤트 수신 로깅: 이벤트 유형, 소스, 시간, 크기 등 기록 (부분 구현)
    - 이벤트 처리 단계 로깅: 시작, 중간 처리, 완료/실패 상태 기록 (부분 구현)
    - 이벤트 발행 로깅: 대상 서비스, 이벤트 유형, 내용 요약 등 기록 (부분 구현)
  - 성능 메트릭 로깅 구현 (미구현)
    - 이벤트 큐 상태 모니터링: 큐 길이, 처리 대기 시간 등 기록 (미구현)
    - 배치 처리 성능 측정: 배치 크기, 처리 시간, 처리율 등 기록 (미구현)
    - 리소스 사용량 모니터링: CPU, 메모리 사용량 등의 시스템 지표 기록 (미구현)
- **검증 방법**:
  - 이벤트 생성 및 처리 시나리오 테스트
  - 높은 부하 상황에서 성능 메트릭이 정확히 기록되는지 확인
  - 다양한 이벤트 유형에 대한 처리 로그 검증

### 3. 로그 수집 및 분석 시스템 구축

#### 3.1 Grafana Alloy + Loki 로그 수집기 설정

- **작업**: Grafana Alloy + Loki 기반 로그 수집 시스템 구축 ✅
- **하위 작업**:
  - Loki 설정 ✅
    - 로그 저장 구성: Loki 스토리지 설정 ✅
    - 보존 기간 설정: 로그 보존 정책 설정 ✅
    - Grafana 연동: Loki 데이터 소스 구성 ✅
  - Grafana Alloy 설치 및 기본 설정 ✅
    - Docker 컨테이너 설정: Alloy 이미지 및 볼륨 마운트 설정 ✅
    - 기본 설정 파일 작성: config.river 기본 설정 ✅
    - JSON 로그 추출 설정: 로그 필드 추출 설정 ✅
  - 로그 수집 파이프라인 구성 ✅
    - 소스 설정: Docker 컨테이너 로그 수집 설정 ✅
    - 파서 설정: JSON 형식 로그 파싱 설정 ✅
    - 라우팅 설정: 서비스 및 로그 레벨별 라우팅 규칙 ✅
- **검증 방법**:
  - 각 서비스에서 생성된 로그가 Loki에 저장되는지 확인
  - 로그 필드가 올바르게 추출되는지 검증
  - Alloy 메트릭을 통한 로그 수집 성능 모니터링

#### 3.2 로그 시각화 대시보드 구축

- **작업**: 로그 분석용 대시보드 구성 (부분 구현)
- **하위 작업**:
  - Grafana 로그 뷰어 구현 ✅
    - Loki 데이터 소스 연결: Grafana에 Loki 데이터 소스 추가 ✅
    - 필터링 및 검색 기능: 서비스, 로그 레벨, 키워드 등으로 필터링 ✅
    - 실시간 로그 스트리밍: 라이브 테일 기능 구현 ✅
  - 에러 모니터링 대시보드 구축 (부분 구현)
    - 에러 발생 빈도 시각화: 시간별, 서비스별 에러 발생 추이 그래프 (부분 구현)
    - 에러 유형 분석: 가장 많이 발생하는 에러 유형 및 원인 분석 (미구현)
    - 알림 임계값 설정: 특정 에러 패턴 감지 시 알림 설정 (미구현)
  - 요청 추적 시각화 구현 (미구현)
    - 트랜잭션 흐름도: 요청 ID 기반 서비스 간 흐름 시각화 (미구현)
    - 성능 타임라인: 각 단계별 처리 시간 시각화 (미구현)
    - 서비스 의존성 그래프: 마이크로서비스 간 호출 관계 시각화 (미구현)
- **검증 방법**:
  - 모든 대시보드 기능이 예상대로 작동하는지 실제 데이터로 테스트
  - 복잡한 트랜잭션을 정확히 추적하고 시각화할 수 있는지 확인
  - 대시보드를 통해 시스템 문제를 효과적으로 진단할 수 있는지 검증

#### 3.3 알림 시스템 구축

- **작업**: 중요 로그 이벤트에 대한 알림 시스템 구축 (미구현)
- **하위 작업**:
  - 심각한 오류 발생 시 알림 규칙 설정 (미구현)
    - 로그 패턴 매칭 규칙: ERROR 레벨 로그 및 특정 패턴(서비스 다운 등) 감지 (미구현)
    - 발생 빈도 기반 알림: 짧은 시간 내 다수의 에러 발생 시 알림 (미구현)
    - 정상 작동 신호(heartbeat) 모니터링: 서비스 응답 없을 때 알림 (미구현)
  - 이메일/슬랙 알림 통합 (미구현)
    - 이메일 알림 설정: SMTP 서버 설정 및 수신자 그룹 관리 (미구현)
    - 슬랙 웹훅 연동: 채널별 알림 설정 및 메시지 포맷 정의 (미구현)
    - 알림 템플릿 작성: 알림 유형별 표준 메시지 형식 정의 (미구현)
  - 알림 임계값 및 조건 설정 (미구현)
    - 서비스별 알림 설정: 각 서비스의 중요도에 따른 알림 수준 차별화 (미구현)
    - 시간대별 알림 정책: 업무 시간/비업무 시간 알림 정책 구분 (미구현)
    - 알림 축소(de-duplication) 로직: 유사 알림 그룹화 및 반복 알림 방지 (미구현)
- **검증 방법**:
  - 다양한 시나리오의 에러를 발생시켜 알림 시스템 작동 테스트
  - 알림 메시지가 지정된 채널로 올바르게 전달되는지 확인
  - 알림 빈도 및 중복 제거 로직이 효과적으로 작동하는지 검증

### 4. 테스트 및 검증

#### 4.1 통합 테스트 구현

- **작업**: 마이크로서비스 간 로깅 통합 테스트 (부분 구현)
- **하위 작업**:
  - 엔드투엔드 테스트 시나리오 작성 (부분 구현)
    - 사용자 인증 흐름: 등록, 로그인, 토큰 검증 등의 전체 프로세스 (부분 구현)
    - 이벤트 처리 흐름: 이벤트 생성부터 처리 완료까지의 흐름 (부분 구현)
    - 에러 시나리오: 다양한 실패 케이스(타임아웃, 서비스 다운 등) (미구현)
  - 분산 요청 추적 테스트 구현 (부분 구현)
    - 요청 ID 전파 테스트: 서비스 간 컨텍스트 전파 검증 (부분 구현)
    - 병렬 처리 테스트: 동시 다발적 요청에서의 컨텍스트 관리 (미구현)
    - 장애 복구 테스트: 일부 서비스 실패 시 로깅 연속성 검증 (미구현)
  - 로그 일관성 검증 테스트 구현 (부분 구현)
    - 포맷 일관성 검증: 모든 서비스의 로그 형식 일관성 확인 (부분 구현)
    - 필수 필드 검증: 모든 로그 엔트리가 필수 필드를 포함하는지 확인 (부분 구현)
    - 시간 동기화 검증: 서비스 간 타임스탬프 일관성 확인 (미구현)
- **검증 방법**:
  - 자동화된 테스트 스크립트를 통한 전체 시나리오 실행
  - Loki에 저장된 로그 분석
  - 로그 분석 도구를 통한 종합적 로그 검증

#### 4.2 성능 테스트

- **작업**: 로깅으로 인한 성능 영향 측정 (미구현)
- **하위 작업**:
  - 로깅 활성화/비활성화 상태에서 성능 측정 (미구현)
    - 기준 성능 측정: 로깅 비활성화 상태에서의 처리량 및 응답 시간 (미구현)
    - 로깅 활성화 성능 측정: 다양한 설정에서의 성능 영향 측정 (미구현)
    - 차이 분석: CPU, 메모리, 네트워크 사용량 차이 분석 (미구현)
  - 로그 레벨별 성능 영향 측정 (미구현)
    - 로그 레벨별 벤치마크: DEBUG, INFO, WARN, ERROR 각 레벨별 성능 측정 (미구현)
    - 로그 양과 성능 상관관계: 로그 엔트리 수와 성능 저하의 관계 분석 (미구현)
    - 최적 로그 레벨 권장안 도출: 환경별(개발, 테스트, 운영) 권장 설정 (미구현)
  - 병렬 요청 처리 시 로깅 성능 측정 (미구현)
    - 동시 사용자 증가에 따른 영향: 점진적 부하 증가 테스트 (미구현)
    - 로그 버퍼링 효과 측정: 동기/비동기 로깅 방식의 성능 비교 (미구현)
    - 로그 압축 효과 측정: 로그 압축 활성화/비활성화 성능 비교 (미구현)
- **검증 방법**:
  - 자동화된 부하 테스트 도구(JMeter, k6 등)를 통한 측정
  - 시스템 모니터링 도구를 통한 리소스 사용량 측정
  - 다양한 설정에서의 성능 비교 결과 문서화

#### 4.3 보안 감사

- **작업**: 로그 데이터 보안 검증 (부분 구현)
- **하위 작업**:
  - 민감 정보 필터링 효과 검증 (부분 구현)
    - 민감 정보 포함 요청 테스트: 실제 민감 데이터로 요청 후 로그 검사 (부분 구현)
    - 자동화된 로그 스캐닝: 정규식을 통한 민감 정보 패턴 검색 (미구현)
    - 우회 패턴 테스트: 일반적인 마스킹을 우회할 수 있는 패턴 테스트 (미구현)
  - 로그 접근 제어 기능 검증 (미구현)
    - 파일 권한 검증: 로그 파일의 시스템 권한 설정 확인 (미구현)
    - 사용자 접근 권한 테스트: 다양한 권한을 가진 사용자의 로그 접근 테스트 (미구현)
    - 로그 백업 및 아카이브 보안: 백업 파일의 암호화 및 접근 제어 확인 (미구현)
  - 규제 준수 여부 확인 (미구현)
    - 개인정보 보호법 준수 검토: 로그에 PII(개인 식별 정보) 포함 여부 검사 (미구현)
    - 보관 기간 정책 검증: 로그 보관 기간 및 삭제 정책 확인 (미구현)
    - 감사 추적 완전성 검증: 중요 작업의 감사 로그 누락 없는지 확인 (미구현)
- **검증 방법**:
  - 보안 전문가 검토를 통한 로깅 시스템 평가
  - 자동화된 보안 스캐닝 도구를 통한 로그 파일 분석
  - 관련 규제 요구사항 대비 준수 여부 체크리스트 작성

## 다음 단계 작업 계획

1. **분산 추적 강화**: OpenTelemetry 도입 검토
2. **성능 테스트 및 최적화**: 로깅 성능 영향 측정 및 개선
3. **알림 시스템 구축**: 로그 기반 알림 시스템 구현
4. **대시보드 개선**: 요청 추적 시각화 기능 강화

## 구현 일정

1. 분산 추적 강화 (OpenTelemetry): 2주
2. 성능 테스트 및 최적화: 1주
3. 알림 시스템 구축: 1주
4. 대시보드 개선: 1주

총 예상 소요 기간: 5주
